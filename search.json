[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python book",
    "section": "",
    "text": "Start your coding journey with Python Book! This book is ideal for beginners to learn to program. Python is a modern high-level programming language that has applications in diverse fields.\nTo learn more about Bioinformatics learning resources, please visit bioinfo.guru.\nFor any query or feedback related to Python Book, please reach out to the author at manish@bioinfo.guru"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Steve Jobs\n\n\n\n“Everyone in this country should learn how to program because it teaches you how to think”"
  },
  {
    "objectID": "intro.html#why-learn-programming",
    "href": "intro.html#why-learn-programming",
    "title": "Introduction",
    "section": "Why learn programming?",
    "text": "Why learn programming?\nThis is a frequently asked question that is why I should learn a programming language. There are multiple merits of having an understanding of the basic framework of computer programs. First, learning a programming language helps us develop logical skills, that’s because programming requires breaking down a problem and approaching a solution in a logical manner. All the computer algorithms are based on the idea that – understand the problem, break it down into different steps, and then go about solving the problem step by step. In the modern world everything is based on computers and having an ability to communicate with computers (via programming language) would help us understand the basis of functioning of any computer program. We’ll be able to “sense” the workflow of a program and to draw a relationship between input(s) and output(s)."
  },
  {
    "objectID": "intro.html#im-a-biologist-why-should-i-learn-to-code",
    "href": "intro.html#im-a-biologist-why-should-i-learn-to-code",
    "title": "Introduction",
    "section": "I’m a biologist, why should I learn to code?",
    "text": "I’m a biologist, why should I learn to code?\nModern Biology research is highly data intensive. Platform technologies are generating data like never before; and to parse the data we need computers. To use computers innovatively and productively, knowledge of programming is a must. Further, there are many software available for bioinformatics research; having an understanding of programming would enable us to interface with these tools in a much better and efficient manner than otherwise. To be a skilled computational biologist we need to understand the workflow that connects – concepts to algorithms to coding. One need not be an expert in all these domains but must have a basic understanding of this workflow. Once you have a vision of the big picture and you are an expert in at least one of these components then you can always collaborate with other experts to do wonderful things together."
  },
  {
    "objectID": "intro.html#why-learn-python",
    "href": "intro.html#why-learn-python",
    "title": "Introduction",
    "section": "Why learn Python?",
    "text": "Why learn Python?\nAnother frequently asked question is why should I learn Python programming Python is the modern programming language that is being actively developed. It offers all the features expected out of a high and programming language that too with a rather flat learning curve. The coding syntax is pretty much like writing in plain English so that it makes it easier for a novice to learn this programming language. This advantage is particularly applicable for researchers in the field of Biology because, conventionally, students of biology have little or no exposure to computer related subjects. So to get them started with programming, Python is an ideal choice. There are of course other advantages as well, like Python is an object oriented programming language. It’s an interpreted language i.e. the code is executed line by line which helps a new coder to identify and debug errors somewhat easily. Most importantly, python offers plenty of libraries to add additional functionality specific to a particular domain. For example, libraries like NumPy and Matplotlib can be used for numerical analysis and data visualization, respectively. Active development and a large user community allows exchange of ideas and speed up troubleshooting tasks.\nIn Bioinformatics, particularly in the recent past, a lot of tools have been developed using python, e.g. one of the most popular structure visualization programs PyMol is developed using Python. Similarly, there are many other libraries that facilitate different kinds of analysis using biological data. Considering all these factors, the ability of code in python is definitely an asset for biologists doing data intensive research."
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "1  Setup",
    "section": "",
    "text": "The first thing that you need to do is to install Python. There are various distributions available online one of the such option is to download from the python offical site. Anaconda is another popular python distribution. Once you have download the executable file the installation is straight forward process."
  },
  {
    "objectID": "setup.html#interactive-development-environments",
    "href": "setup.html#interactive-development-environments",
    "title": "1  Setup",
    "section": "1.2 Interactive Development Environments",
    "text": "1.2 Interactive Development Environments\nAfter python installation the next thing you need is a code editor. Although any text editor (such as Notepad++/vi/TextEdit) can serve this purpose but it is highly recommend to install atleat one IDE (Interactive Development Environment). The Anaconda distribution comes bundled with Jupyter (an IDE). VS Code (Visual Studio Code) is an other popular IDE among software deveplopers. The IDEs have several useful features such as syntax highlighting, code auto-completion, options to install plugin, etc. that elevate the coding experience. The figure below shows the interface for Jupyter and VS Code.\n\n\n\n\n\n\n\n(a) Jupyter\n\n\n\n\n\n\n\n(b) VS Code\n\n\n\n\nFigure 1.1: Interactive Development Environments (IDEs)\n\n\nIn addition to these IDEs, Google Collaboratory is an online Jupyter notebook that can be used to execute python code in the cloud.\nThroughout this book, the python code is shown as a code block with grey background, e.g.\n\nprint(\"Hello World!\")\n\n\n\n\n\n\n\nQuick tip\n\n\n\nWhen you hover the mouse pointer over a code cell, there will be an option on the right to copy the contents of that cell."
  },
  {
    "objectID": "setup.html#useful-links",
    "href": "setup.html#useful-links",
    "title": "1  Setup",
    "section": "1.3 Useful links",
    "text": "1.3 Useful links\n\n\n\nName\nWebsite\n\n\n\n\nPython website\nhttps://python.org\n\n\nAnaconda\nhttps://www.anaconda.com/products/individual\n\n\nGoogle Colab\nhttps://research.google.com/colaboratory/\n\n\nVS Code\nhttps://code.visualstudio.com/"
  },
  {
    "objectID": "Variables_Operators.html",
    "href": "Variables_Operators.html",
    "title": "2  Variables",
    "section": "",
    "text": "In programming variables refers to a “name” for a value. This “name” can have different values over the course of program and hence it is referred as a variable. The concept of variable in programming is similar to some of terms used in natural languages to refer to different things. For instance, in a classroom there are students with different names. Here the word name is a variable which has differnt value for each student i.e. their name.\nThe above statement initializes a variable named ‘a’ with a numeric value of 2 and it is refered to as an Assignment Statement. Similarly, the statement below initializes a variable with name ‘test’ and assigns a string value of ‘Happy’\nWe can print the value of a variable using the print command i.e.\nThe value assigned to a variable can be changed within the program. This feautre make variable very useful and are extensively used in progamming. A variable, for example, can be used to store user input.\nEach variable in Python has 6 properties associated with it. For now only first three are required since the last three are for advanced programmers. These properties are 1. Name 2. Value 3. Type 4. Scope 5. Life time 6. Memory location\nThe first two properties i.e. name and value we have already seen above. Type for a variable refers to it’s data type i.e. whether the variable is an integer, float, string, boolean, etc.\nIn Python, the type for a variable is decided at the time of initialization. This behaviour is different from languages like C where the type of the variable has to be declared explicitly. In the example above, we can change the variable ‘a’ to a non numeric value. To check the type for a particular variable, type() function can be used as follows.\nVariable names are case sensitive, e.g. in the code below there are four different variables such that their name differ only in the case used for the letters."
  },
  {
    "objectID": "Variables_Operators.html#operators",
    "href": "Variables_Operators.html#operators",
    "title": "2  Variables",
    "section": "2.1 Operators",
    "text": "2.1 Operators\nAn operator is a special symbol that instructs the compiler/interpreter to execute specific mathematical or logical operations. These symbols operate on set of variable or scaler or both. Operand refers to the value that operator operates on. E.g., in the equation 2+3 ‘+’ is an operator and 2 and 3 are operands.\nIn Python there are 6 different classes of operators. These are: 1. Arithmetic operators 2. Comparison operators 3. Logical operators 4. Assignment operators 5. Bitwise operators 6. Special operators\nLet’s understand each of these classes through some examples"
  },
  {
    "objectID": "Variables_Operators.html#arithmetic-operators",
    "href": "Variables_Operators.html#arithmetic-operators",
    "title": "2  Variables",
    "section": "2.2 Arithmetic operators",
    "text": "2.2 Arithmetic operators\nAs the name suggests this class of operators are used to perform mathematical operation on the operands. Following is the list of arithemetic operators available in Python.\n\n\n\nOperator Symbol\nMeaning\nExample\n\n\n\n\n+\nAddition\n2 + 2 = 4\n\n\n-\nSubtraction\n5 - 2 = 3\n\n\n*\nMultiplication\n2 * 3 = 6\n\n\n/\nDivision\n4 / 2 = 2\n\n\n%\nModulus\n4 % 2 = 0\n\n\n//\nFloor division\n5 // 2 = 2\n\n\n**\nExponent\n2 ** 3 = 8\n\n\n\n\nx = 4\ny = 5\nprint (x+y+2)\nprint (x-y+2)\n\n11\n1"
  },
  {
    "objectID": "Variables_Operators.html#comparison-operator",
    "href": "Variables_Operators.html#comparison-operator",
    "title": "2  Variables",
    "section": "2.3 Comparison operator",
    "text": "2.3 Comparison operator\nThese operators are used to compare operands and the output from their operation is a boolean value i.e. either True or False or equivalently 1 or 0.\nFollowing is the list of arithemetic operators available in Python.\n\n\n\nOperator Symbol\nMeaning\nExample\n\n\n\n\n>\nGreater than\n3 > 2 is True\n\n\n<\nLess than\n3 < 2 is False\n\n\n==\nEqual to\n2 == 3 is False\n\n\n!=\nNot equal to\n2 != 3 is True\n\n\n>=\nGreater than or equal to\n4 >= 2 is True\n\n\n<=\nLess than or equal to\n5 <= 2 is False\n\n\n\n\nx = 4\ny = 5\nprint (x+y > 10)\n\nFalse"
  },
  {
    "objectID": "Variables_Operators.html#logical-operators",
    "href": "Variables_Operators.html#logical-operators",
    "title": "2  Variables",
    "section": "2.4 Logical operators",
    "text": "2.4 Logical operators\nThere are 3 logical operators and, or, and not.\n\n\n\nOperator Symbol\nMeaning\n\n\n\n\nand\nTrue if both operands are true\n\n\nor\nTrue if either of the operands is true\n\n\nnot\nTrue if operands are false\n\n\n\n\nx = True\ny = False\nprint (x and y)\nprint (x or y)\nprint (not x)\n\nFalse\nTrue\nFalse\n\n\n\nx=5\ny=6\nz=7\nprint (x<y and y<z)\n\nTrue"
  },
  {
    "objectID": "Variables_Operators.html#assignment-operators",
    "href": "Variables_Operators.html#assignment-operators",
    "title": "2  Variables",
    "section": "2.5 Assignment operators",
    "text": "2.5 Assignment operators\nOperators in this class are used to assign values to variables. The syntax for using these operators is variable name followed by operator followed by the value that is to be assigned. Some of the assignment operator behave equivalent to the mathematical operation performed by arithmetic operators.\nFollowing is the list of assignment operators available in Python.\n\n\n\n\n\n\n\n\nOperator Symbol\nMeaning\nExample\n\n\n\n\n=\nAssign value on the right to variable on the left\nx = 5\n\n\n+=\nIncrement value of the variable by value on the right\nx += 5 (x = x + 5)\n\n\n-=\nDecrement value of the variable by value on the right\nx -= 5 (x = x - 5)\n\n\n*=\nMultiple value of the variable by value on the right\nx = 5 (x = x  5)\n\n\n/=\nDivide value of the variable by value on the right\nx /= 5 (x = x / 5)\n\n\n%=\nModulus for the value of the variable by value on the right\nx %= 5 (x = x % 5)\n\n\n//=\nFloor division of value of the variable by value on the right\nx //= 5 (x = x // 5)\n\n\n**=\nExponent value of the variable by value on the right\nx **= 5 (x = x ** 5)\n\n\n\n\nQuiz: What would be the output of the following code  x = 6  x **= 2  print(x)\n\n\n\nShow answer\n36\n\n\n\nQuiz: What would be the output of the following code  x = False  print(type(x))\n\n\n\nShow answer\nx = False\nprint(type(x))\n\n#output \n#<class 'bool'>"
  },
  {
    "objectID": "Strings.html",
    "href": "Strings.html",
    "title": "3  Strings",
    "section": "",
    "text": "In programming string refers to a sequence of characters that can act as a variable or constant. This is the most popular data type in Python. In fact the increasingly strong prevelance of Python in Bioinformatics is primarily due to its ability to easily perform different operations of strings. A string variable can be assigned a value using either single or double quotes.\nTo check the data type of a variable, we can use the type function. The get number of character in a string variable use the len function. Note that a blank space is also considered as a character."
  },
  {
    "objectID": "Strings.html#string-concatenation",
    "href": "Strings.html#string-concatenation",
    "title": "3  Strings",
    "section": "3.1 String concatenation",
    "text": "3.1 String concatenation\nThe process of joining two or more things is called as concatenation. The arithmetic operators + and * can be used directly with strings to concatenate (addition) or repeat (multiplication). This process of giving additional functions to operator (beyond their existing functions) is called as operator overloading. E.g. the plus (+) operator is used for addition given that the operands are integers. However, if the operands are string then it act as a concatenation operator instead of addition operator.\n\n# The plus (+) operator with two numbers\n2+3\n\n5\n\n\n\nvar1 = \"Hello\"\nvar2 = \"World!\"\nprint (var1+var2)\n\nHelloWorld!\n\n\nIn the case of asteriks (*) operator, which is used to multiple two numbers, when the operands are a string (s) and a number (n) the output is s repeated n times. This behaviour is similar to muliplication of two numbers. For instance, let say we want to multiple 5 by 3 (5*3). This multiplication can also be represented as sum of 5 three times i.e. 5+5+5. So, when we use a string (s) and a number (n) as operands for * operator we get s+s+s…(n times).\n\nvar3 = var1*3\nprint(var3)\n\nHelloHelloHello"
  },
  {
    "objectID": "Strings.html#slice-of-a-string",
    "href": "Strings.html#slice-of-a-string",
    "title": "3  Strings",
    "section": "3.2 Slice of a string",
    "text": "3.2 Slice of a string\nSlice is another very useful operator that can be used to manipulate strings. The slice operator [] gives the character within the start and end positions separated by a colon. The numbering of characters within a string start from 0. Note that the start position character is included in the output but the end position character is not. Slicing effectively return the substring of a given string. The general syntax for slicing a string is as follows:\nstring[start:end] string[start:] string[:end] string[start:end:step]\nLet’s see some examples to get a better understanding to the slice operation.\n\nvar4 = \"ABCDEFG\"\nprint(var4)\nprint(var4[1:5])\n\nABCDEFG\nBCDE\n\n\nIn case no value is specified before or after the colon then the slicing would occur from begining or till end respectively.\n\nprint(var3)\nprint(var3[:7])\nprint(var3[3:])\n\nHelloHelloHello\nHelloHe\nloHelloHello\n\n\nThe step part in the slice operator specific the number of steps to take when going from the start position to the end position. The default step size is 1. We can change the default value by specifying the step parameter within the slice command.\n\nprint(var3)\nprint(var3[2::2])\n\nHelloHelloHello\nloelHlo\n\n\n\nQuiz: Write a command that outputs ‘HHH’ given a string ‘HelloHelloHello’.\n\n\n\nShow answer\nvar3 = \"HelloHelloHello\"\nprint(var3[::5])"
  },
  {
    "objectID": "Strings.html#string-comparison",
    "href": "Strings.html#string-comparison",
    "title": "3  Strings",
    "section": "3.3 String comparison",
    "text": "3.3 String comparison\nOne of the frequently required tasks in programming is string comparison. In Python comparison operator can be used to compare two strings. The == (two equal symbols without space) is the comparison operator. The output of comparison is a boolean value i.e. either True or False. String comparison is case sensitive.\n\nvar1 = 'Hello'\nvar2 = \"Hello\"\nvar3 = 'Hi'\nprint(var1 == var2)\nprint(var1 == var3)\nprint(var1 == \"hello\")\n\nTrue\nFalse\nFalse"
  },
  {
    "objectID": "Strings.html#spliting-string",
    "href": "Strings.html#spliting-string",
    "title": "3  Strings",
    "section": "3.4 Spliting string",
    "text": "3.4 Spliting string\nSometimes there is a need to split a string based on certain delimiters, the split function is designed for that task. Python String types have split function associated with them that return a list of elements after spliting the string as per the delimiter. The default delimiter is blank space.\n\ns1 = \"This is a sentence.\"\nwords1 = s1.split()\nprint(words1)\n\n#split with comma as a delimiter\ns2 = 'This is an another sentence, a longer one.'\nwords2 = s2.split(\",\")\nprint(words2)\n\n['This', 'is', 'a', 'sentence.']\n['This is an another sentence', ' a longer one.']\n\n\n\nQuiz: What would be the output if we split s2 using “is” as a delimiter.\n\n\n\nShow answer\ns2 = 'This is an another sentence, a longer one.'\nprint(s2.split(\"is\"))\n\n##Output would be a list with three elements:\n##['Th', ' ', ' an another sentence, a longer one.']"
  },
  {
    "objectID": "Strings.html#string-functions",
    "href": "Strings.html#string-functions",
    "title": "3  Strings",
    "section": "3.5 String functions",
    "text": "3.5 String functions\nPython strings have several methods to work with string objects. Below are examples of some of the functions available is class ‘str’. These methods acts on the string and returns a new string after doing the required manipulations. For additional functions, please refer to the python documentation.\n\n\ns1 = \"Apple\"\n\nString function           Output\n————————————————————————————————\ns1.upper()                APPLE\ns1.lower()                apple\ns1.startswith(\"a\")        False\ns1.startswith(\"A\")        True\ns1.index(\"l\")             3\ns1.replace(\"e\",\"es\")      Apples"
  },
  {
    "objectID": "Strings.html#doc-strings",
    "href": "Strings.html#doc-strings",
    "title": "3  Strings",
    "section": "3.6 Doc strings",
    "text": "3.6 Doc strings\nTo declare a variable whose value is a long string that spans multiple lines tripple quotes can be used. All white spaces such as tabs and newline are considered part of the string. These types of strings are generally used for documentation purposes e.g. writing help text for custom functions.\n\nvar4 = \"\"\"This is an example of\na long string that spans \nthree lines.\"\"\"\nprint (var4)\n\nThis is an example of\na long string that spans \nthree lines."
  },
  {
    "objectID": "Strings.html#strings-key-characteristics",
    "href": "Strings.html#strings-key-characteristics",
    "title": "3  Strings",
    "section": "3.7 Strings – key characteristics",
    "text": "3.7 Strings – key characteristics\n\nA string variable stores text data\n\nA string variable can store characters including white spaces (space, tab, newline). A string variable is an object of class ‘str’. To initialize a string variable, single or double quotes can be used.\n\nA string variable is immutable\n\nIn Python the strings are immutable i.e. their value cannot be changed once it has been assigned. The values can however be reassigned. The value of a string variable can change but the data contained within a variable can`t be changed.\n\nA strings variable is a list\n\nA string variable is a also a list i.e. a collection of characters. We can iterate through characters in a string just like we can iterate through any list. Unlike lists, however, characters cannot be appended to a string because strings are a immutable data type."
  },
  {
    "objectID": "Numbers.html",
    "href": "Numbers.html",
    "title": "4  Numbers",
    "section": "",
    "text": "Python has a couple of different options for data types when it comes to working with numbers. Numbers without and with demical points are refered to as int (integers) and float (floating point). So, depending upon how we initialize a variable, its data type would be assigned accordingly. Both these data types can have negative values. The int and float functions can be used to explicity assign the corresponding data types. Note, when assigning and int data type to a number with decimal value, only the interger part is retained. For working with complex numbers there is an additional data type complex.\nA numeric variable can also be initiatlized using scientific notation i.e. e notation. The e can be both lower or upper case. Variables declared with a scientific notation are always float.\nThe data type for the output of an arithmetic operator would depend on the data type of the operands. If both the operands are int then the output would also be int. An exception to this is / (division) where the data type for the output is always float irrespective of the data type of the operands. Also, if at least one of the operand is float then the data type for the output would be float."
  },
  {
    "objectID": "Numbers.html#formatted-print",
    "href": "Numbers.html#formatted-print",
    "title": "4  Numbers",
    "section": "4.1 Formatted print",
    "text": "4.1 Formatted print\nTo print a floating point number with a desired number of decimal places we can use the formatted print option. The %f format specifier can be used to indicate the required number of decimal places for the output. Here, we also have an option to include the sign (+) in case of positive number. In addition to this, the round function can also be used which takes two arguments – the floating point number and the required number of decimal places.\n\n\nn = 1234.5678\n\nFormatted print           Output\n————————————————————————————————\nprint(\"%.2f\" % n)         1234.57\nprint(\"%+.2f\" % n)        +1234.57\nprint(\"%.2e\" % n)         1.23e+03\nprint(\"%.d\" % n)          1234"
  },
  {
    "objectID": "Numbers.html#f-strings",
    "href": "Numbers.html#f-strings",
    "title": "4  Numbers",
    "section": "4.2 f-strings",
    "text": "4.2 f-strings\nFrom python 3.6 onwards, formatting of variable, calculations of mathematical expression etc. can be easily done within the print statement. These string starts with f. The variables inside the f-strings are enclosed within curly braces {}. The formatting is similar to as we described above, the code is relatively cleaner and easy to follow.\n\na = -4\nb = 5.0\nprint(f'The product of {a} and {b} is {a*b}')\nprint(f'The product of {a} and {b} is {a*b:0.3f}')\n\nThe product of -4 and 5.0 is -20.0\nThe product of -4 and 5.0 is -20.000"
  },
  {
    "objectID": "Numbers.html#complex-numbers",
    "href": "Numbers.html#complex-numbers",
    "title": "4  Numbers",
    "section": "4.3 Complex numbers",
    "text": "4.3 Complex numbers\nComplex numbers can be initialized using the complex function which takes either one or two arguments, depending upon the nature of argument: - a complex number is specified directly - the real and imaginary parts are specified as separate arguments.\n\nc = complex(3+6j)\nz = complex(5,2)\nprint(c, z)\nprint(f\"The real component of z is {z.real}\")\nprint(f\"The imaginary component of z is {z.imag}\")\nprint(f\"The conjugate of z is {z.conjugate()}\")\n\n(3+6j) (5+2j)\nThe real component of z is 5.0\nThe imaginary component of z is 2.0\nThe conjugate of z is (5-2j)"
  },
  {
    "objectID": "Loops.html",
    "href": "Loops.html",
    "title": "5  Loops and conditionals",
    "section": "",
    "text": "In programming often times there is a requirement that a particular set of instructions is required to be repeated certain number of times. This can be easily achieved using loops. These statements execute a code block repeatedly for specified number of times or until a condition is met."
  },
  {
    "objectID": "Loops.html#for-loop",
    "href": "Loops.html#for-loop",
    "title": "5  Loops and conditionals",
    "section": "5.1 For loop",
    "text": "5.1 For loop\nThe most common loop that is used to repeat a block of code for fixed number of times is for loop. The example below show iterating through all the elements of a list.\n\nlist_of_numbers = [1, 2, 3, 4, 5] \nfor x in list_of_numbers:\n    print(x*2)\nprint(\"Done\")\n\n2\n4\n6\n8\n10\nDone\n\n\nThe for statement begins with the for keyword which is followed by a variable name (x in the example above). This variable would store the different elements in the list as the loop progressess. The in keyword connects the variable with the list and finally we have the list that we want to iterate. The colon (:) at the end is required. It indicates the begining of the block of statements that would be part of the for loop. Next, we have a set of statement that needs to executed for each element of the list. The statement that are part of the for loop must begin with indentation (tab or some spaces). In the example above, the print(x*2) statement is part of the for loop (since it is indented) while the print(\"Done\") statement is not part of the for loop since it is not indented. There must be atleast one statement which is part of the for loop (i.e. atleast one statement that starts with indentation)."
  },
  {
    "objectID": "Loops.html#conditionals",
    "href": "Loops.html#conditionals",
    "title": "5  Loops and conditionals",
    "section": "5.2 Conditionals",
    "text": "5.2 Conditionals\nTo test a particular condition, if statement is used with an argument having a Boolean operator. Multiple conditions can be tested in one code block using elif. The else keyword take no argument such that its code block gets executed when the if condition (and elif) conditions are return False. Just like for loops, the mandatory requirement of colon (:) and indentation applies in the case of if-else conditions.\n\nx = 5\ny = 6\n\nif(x>y):\n    print(\"X is greater than Y\")\nelse:\n    print(\"X is less than Y\")\n\n\nQuiz: Write a program that takes two numbers as input and prints the result of their comparison. The code should consider the case when the two numbers are equal.\n\n\n\nShow answer\nx = 5\ny = 5\n\nif(x>y):\n    print(\"X is greater than Y\")\nelif(x<y):\n    print(\"X is less than Y\")\nelse:\n    print(\"X is equal to Y\")"
  },
  {
    "objectID": "Loops.html#while-loop",
    "href": "Loops.html#while-loop",
    "title": "5  Loops and conditionals",
    "section": "5.3 While loop",
    "text": "5.3 While loop\nWhile loop is another frequently used construct to perform task repeatedly when the number of iterations is not fixed. This loop is executed till certain condition is met irrespective of number of iterations.\nWhile expression:\n    code block\nWhile loop implicitly has if conditional statement.\n\nx = 5\nwhile(x>2):\n    print(x)\n    x = x-1\nprint(\"Loop is over\")\n\n5\n4\n3\nLoop is over\n\n\nWhen writting a while loop you must ensure that the condition is met at some point within the loop otherwise the loop will iterate infinitely. E.g. in the above code if the condition within while loop is changed to x>2 then it result in an infinite loop."
  },
  {
    "objectID": "Loops.html#controlling-the-execution-of-loops",
    "href": "Loops.html#controlling-the-execution-of-loops",
    "title": "5  Loops and conditionals",
    "section": "5.4 Controlling the execution of loops",
    "text": "5.4 Controlling the execution of loops\nMany a times it is require to skip the execution of loop for certain steps or to terminate the loop altogether. Python has some reserved keyword to facilitate this task. continue can be used to jump to subsequent iteration of the loop and break can be used to end the loop.\n\nfor x in range (1,10):\n    if (x == 5):\n        continue\n    print(x)\nprint(\"Done\")\n\n1\n2\n3\n4\n6\n7\n8\n9\nDone\n\n\n\nfor x in range (1,10):\n    if (x == 5):\n        break\n    print(x)\nprint(\"Done\")\n\n1\n2\n3\n4\nDone\n\n\n\nQuiz: Take a list of first 10 numbers and print the square for even numbers.\n\n\n\nShow answer\nfor x in range(1,11):\n    if(x%2 == 0):\n        print(x**2)\n    else:\n        continue"
  },
  {
    "objectID": "Lists.html",
    "href": "Lists.html",
    "title": "6  Lists",
    "section": "",
    "text": "A collection of items, in python, is refered to as a list. A list can have elements of same data type or multiple data types. A list is denoted by square brackets ([]). The indexing of elements in a list starts from zero. To access an element by its index we can specify index in square brackets after the list name. Slicing of lists can be performed as well.\nLists are mutable data type i.e. the contents of the collection can be changed. The append and extend functions adds an element or a collection of elements to a list. To add an element at a specified position within the list, the insert function can be used.\nTo remove the last element from a list, pop function can be used. It returns a the last element and the original list is shortened by one element. To remove an element by its name use the remove function. Note that if a list has duplicate elements then the remove function would delete only the first occurance of that element."
  },
  {
    "objectID": "Lists.html#list-functions",
    "href": "Lists.html#list-functions",
    "title": "6  Lists",
    "section": "6.1 List functions",
    "text": "6.1 List functions\nThere are some useful functions available to manupulate lists. These functions act in place i.e. these functions do not return anything and just modifies the original list.\n\nfruits = ['apple', 'banana', 'mango', 'pineapple', 'cherry', 'banana']\nprint(fruits.count(\"banana\"))\nfruits.reverse()\nprint(fruits)\nfruits.sort()\nprint(fruits)\nfruits.sort(reverse=True)\nprint(fruits)\n\n2\n['banana', 'cherry', 'pineapple', 'mango', 'banana', 'apple']\n['apple', 'banana', 'banana', 'cherry', 'mango', 'pineapple']\n['pineapple', 'mango', 'cherry', 'banana', 'banana', 'apple']\n\n\n\nQuiz: Given a list nums=[1,2,3,4,5]. Write a code to print 4.\n\n\n\nShow answer\nnums = [1,2,3,4,5]\nprint(nums[3])"
  },
  {
    "objectID": "Tuples.html",
    "href": "Tuples.html",
    "title": "7  Tuples",
    "section": "",
    "text": "fruits = (\"apple\", \"banana\", \"mango\")\nprint(fruits)\nprint(type(fruits))\nprint(fruits[1])\n\n('apple', 'banana', 'mango')\n<class 'tuple'>\nbanana\n\n\n\nfruits2 = \"pineapple\", \"cherry\"\nprint(fruits2)\n\n('pineapple', 'cherry')\n\n\n\nnums = [1,2,3,4,5]\nnums_tuple = tuple(nums)\nprint(nums_tuple)\n\n(1, 2, 3, 4, 5)\n\n\nTuple can be concatenated in the same manner as strings are concatenated. The + and * operators can be used for tuple concatenation.\n\nprint(fruits+fruits2)\nprint(fruits2*3)\n\n('apple', 'banana', 'mango', 'pineapple', 'cherry')\n('pineapple', 'cherry', 'pineapple', 'cherry', 'pineapple', 'cherry')\n\n\n\nQuiz: What would be the output of the following code. fruits = (“apple”, “mango”) fruits.append(“grapes”)     print(fruits)\n\n\n\nShow answer\nError. Tuples are immutable."
  },
  {
    "objectID": "Dictionaries.html",
    "href": "Dictionaries.html",
    "title": "8  Dictionaries",
    "section": "",
    "text": "colors = {'blue':'sky', 'white':'milk', 'red':'rose'}\nprint(colors)\nprint(type(colors))\nprint(colors[\"red\"])\n\n{'blue': 'sky', 'white': 'milk', 'red': 'rose'}\n<class 'dict'>\nrose\n\n\nAn alternate way to initialize a dictionary is by using the dict keyword. In the code below, notice the differences in how the key-value pairs are specified while inititalize a dictionary with the dict keyword.\n\ncolors_new = dict(blue=\"ink\", white=\"paper\")\nprint(colors_new)\n\n{'blue': 'ink', 'white': 'paper'}\n\n\nThe values in a dictionary could any data type such as string, integer, list or even dictionary. On the other hand, keys can only be immutable data types such as string, integer or tuple.\n\n# a dictionary with numbers as keys\nNumbers = {1:\"one\", 2:\"two\"}\nprint(Numbers[1])\n\none\n\n\n\n# a dictionary with list as values\nstationery = {\"pens\":[\"ball\", \"fountain\"], \"paper\":[\"A4\", \"A3\", \"A2\"]}\nprint(stationery[\"paper\"])\nprint(stationery[\"paper\"][1])\n\n['A4', 'A3', 'A2']\nA3\n\n\nThe keys and values functions can be used to get all keys and all values as a list, respectively. The items function can be used to iterate through the content of the dictionary. This function return the key-value pairs as a tuple and all these key-value tuples are arranged in a list. We can then iterate through this list to access the key-value pairs. Note that while iterating through this list, two variables need to be specified in the for loop which would be mapped to the key and value in the tuple, respectively.\n\nprint(stationery.keys())\nprint(stationery.values())\nprint(stationery.items())\n\ndict_keys(['pens', 'paper'])\ndict_values([['ball', 'fountain'], ['A4', 'A3', 'A2']])\ndict_items([('pens', ['ball', 'fountain']), ('paper', ['A4', 'A3', 'A2'])])\n\n\n\nfor k1, v1 in stationery.items():\n    print(f\"The key is {k1} and its value is {v1}\")\n\nThe key is pens and its value is ['ball', 'fountain']\nThe key is paper and its value is ['A4', 'A3', 'A2']\n\n\nJust like lists, we can modify the contents of a dictionary by adding or removing key-value pairs. When adding a key-value pair if the key doesn’t exists then a new key would be created while if the key is already present then its value would be modified.\n\nNumbers = {1:\"one\", 2:\"two\"}\nprint(Numbers)\nNumbers[3] = \"three\"\nprint(Numbers)\nNumbers[2] = \"dos\"\nprint(Numbers)\n\n{1: 'one', 2: 'two'}\n{1: 'one', 2: 'two', 3: 'three'}\n{1: 'one', 2: 'dos', 3: 'three'}\n\n\n\ndel(Numbers[2])\nprint(Numbers)\n\n{1: 'one', 3: 'three'}\n\n\n\nQuiz: Given a dictionary: d1 = {1:“one”, 2:“two”, 3:“three”} Write a code to check if “two” is present 1) as a key and 2) as a value.\n\n\n\nShow answer\nd1 = {1:\"one\", 2:\"two\", 3:\"three\"}\nif(\"two\" in d1.keys()):\n    print('\"two\" is a key in d1')\nif(\"two\" in d1.values()):\n    print('\"two\" is a value in d1')\n    \n# Alternate solution\nprint(\"Alternate solution\")\nfor k1,v1 in d1.items():\n    if(\"two\" == k1):\n        print('\"two\" is a key in d1')\n    if(\"two\" == v1):\n        print('\"two\" is a value in d1')"
  },
  {
    "objectID": "Files.html",
    "href": "Files.html",
    "title": "9  File Handling",
    "section": "",
    "text": "Saving and retrieving information is frequently required when working with computer programs. Python has methods to read and write files. In addition, there are some library that can facilitate working with specialized file types. For reading a file, a file handler need to be initated which is an object that can be use to work with file. A file handler incorporates information about the file along with its path and the mode in which the file is available for processing. The mode here refers to the manner in which the file would be opened i.e. for reading, writing, etc. The open function takes name of the file as an argument along with mode and returns the corresponding file handler. This file handler object is iteratable and can be considered as a list having of all the lines in the file. Once done with reading the contents for the file, the file handler must be closed using the close function."
  },
  {
    "objectID": "Files.html#reading-files",
    "href": "Files.html#reading-files",
    "title": "9  File Handling",
    "section": "9.1 Reading files",
    "text": "9.1 Reading files\n\n# test_file.txt should be present in the current working directory.\nFH1 = open('test_file.txt','r')\nprint(f\"The file {FH1.name} is open in {FH1.mode} mode.\")\n\n# print all the lines in the file.\nfor lines in FH1:\n    print(lines)\nFH1.close()\n\nThe file test_file.txt is open in r mode.\nThis is a test file for Python.\n\nThis file has .txt extension.\n\n\n\nOften it is useful to remove the newline character (‘’) at the end of the lines since the print fuction add as newline by default. This can be achieved using the rstrip() function. This function without any argument remove the last character in the string and return a copy of the modified string."
  },
  {
    "objectID": "Files.html#writing-files",
    "href": "Files.html#writing-files",
    "title": "9  File Handling",
    "section": "9.2 Writing files",
    "text": "9.2 Writing files\nFor writing content to a file the open function should be called with ‘w’ as the mode. When a file is opened in the write mode, a new file is created. In case there the file already exists then its contents are overwritten (without warning!). write function is used to write content to a file. We can also use print with file attribute to write to file instead of printing on screen.\n\nFH_out = open('temp_file.txt', 'w')\nFH_out.write(\"This is the first sentence.\\n\")\nprint(\"This is the second sentence.\", file=FH_out)\nFH_out.close()\n\n\nFH2 = open('temp_file.txt','r')\nfor lines in FH2:\n    print(lines)\nFH2.close()\n\nThis is the first sentence.\n\nThis is the second sentence.\n\n\n\nTo append contents to an existing file, it should be opened with ‘a’ option instead of ‘w’.\n\nFH_out = open('temp_file.txt','a')\nFH_out.write(\"This is the third sentence.\\n\")\nFH_out.write(\"This is the \\t fourth sentence.\\n\")\nFH_out.close()\n\n\nFH3 = open('temp_file.txt','r')\nfor lines in FH3:\n    lines = lines.rstrip('\\n')\n    print(lines)\nFH3.close()\n\nThis is the first sentence.\nThis is the second sentence.\nThis is the third sentence.\nThis is the      fourth sentence.\n\n\nThe readlines function can be used to get a list having lines of the file as elements.\n\nFH4 = open('temp_file.txt','r')\nall_lines = FH4.readlines()\nprint(all_lines)\nFH4.close()\n\n['This is the first sentence.\\n', 'This is the second sentence.\\n', 'This is the third sentence.\\n', 'This is the \\t fourth sentence.\\n']"
  },
  {
    "objectID": "Files.html#the-with-keyword",
    "href": "Files.html#the-with-keyword",
    "title": "9  File Handling",
    "section": "9.3 The with keyword",
    "text": "9.3 The with keyword\nWe can also read and write file using the with keyword. Here some action are performed on the file object within the with block. This approach automatically closes the when the with block is over.\n\nwith open(\"temp123.txt\", \"w\") as FH_OUT:\n    print(\"Hello\", file=FH_OUT, end=\" \") \n    print(\"World!\", file=FH_OUT)\nprint(\"Done\")\n\nDone\n\n\n\nwith open(\"temp123.txt\", \"a\") as FH_OUT:\n    print(\"hi\", file=FH_OUT)\n\n\nwith open(\"temp123.txt\",\"r\") as FH:\n    for line in FH.readlines():\n        print(line)\n\nHello World!\n\nhi\n\n\n\n\nQuiz: Write a program to print the third line of a text file.\n\n\n\nShow answer\n#temp_file.txt should be there in the current directory\nFH = open('temp_file.txt','r')\nall_lines = FH.readlines()\nprint(all_lines[2])"
  },
  {
    "objectID": "Numpy.html",
    "href": "Numpy.html",
    "title": "10  NumPy",
    "section": "",
    "text": "A Python library for scientific computing. It features multidimensional array objects along with an assortment of functions optimized for fast computation. To use this library we first need to import it as shown below. After that we’ll have access to all the functions within the NumPy library. Let’s create a numpy array.\nAlthough the array looks like a list but it has very different properties and functions associated with it as compared to the python list. For example, there is no built-in function to change the shape of a list or to transpose a list whereas these operations can be done seemlessly with ndarrays. The shape function returns the dimensions of an ndarray as a tuple and the reshape function changes the shape of an ndarray given a tuple.\nThe transpose and ravel functions can be used to transpose and flatten multidimensional arrays. For tranposition, we can also use .T attribute of a numpy array.\nThere are various functions available in NumPy to create arrays e.g. zeros, ones, empty, random can be used to create an ndarray having all the values as zero, one, no value, or random values, respectively. These three functions take shape of the array as an argument and data type can be optionally specified. arange is another function that can be used to initialize an array with specific values. This function is similar to the range function with a difference that it return an array while the range function returns a list.\nlinspace is another useful function to generate specified number of equally spaced values within a given range. It takes three numbers as argument, the first two numbers specify the range (both number included) and the third number specifies the number of values to return."
  },
  {
    "objectID": "Numpy.html#reading-data-from-file",
    "href": "Numpy.html#reading-data-from-file",
    "title": "10  NumPy",
    "section": "10.1 Reading data from file",
    "text": "10.1 Reading data from file\nNumpy has genfromtxt function that comes handy for reading data from text files. The example below show read a csv file using this function.\n\n# %load test1.csv\n1, 1, 1\n2, 4, 8\n3, 9, 27\n4, 16, 64\n5, 25, 125\n\n\ninp_data = np.genfromtxt(\"test1.csv\", delimiter=\",\")\nprint(inp_data)\nprint(inp_data.shape)\n\n[[  1.   1.   1.]\n [  2.   4.   8.]\n [  3.   9.  27.]\n [  4.  16.  64.]\n [  5.  25. 125.]]\n(5, 3)\n\n\n\nsub_matrix = inp_data[1:4]\nprint(sub_matrix)\n\n[[ 2.  4.  8.]\n [ 3.  9. 27.]\n [ 4. 16. 64.]]"
  },
  {
    "objectID": "Numpy.html#writing-data-to-file",
    "href": "Numpy.html#writing-data-to-file",
    "title": "10  NumPy",
    "section": "10.2 Writing data to file",
    "text": "10.2 Writing data to file\nNumpy has savetxt function that can be used to save numpy arrays to a text file in e.g. csv format. There is an option to change the delimiter. The example below shows writing a csv file using this function with space as a delimiter. The fmt argument is used to specify the format in which to write the data.\n\nnp.savetxt(\"test2.csv\",sub_matrix, delimiter=\" \", fmt='%d')\n\n\n# %load test2.csv\n2 4 8\n3 9 27\n4 16 64"
  },
  {
    "objectID": "Numpy.html#slicing-multidimensional-arrays",
    "href": "Numpy.html#slicing-multidimensional-arrays",
    "title": "10  NumPy",
    "section": "10.3 Slicing multidimensional arrays",
    "text": "10.3 Slicing multidimensional arrays\nJust like we can splice a string or list, slicing of numpy arrays can also be performed. While in case of a sting or a list the slice operator takes the start and end positions, in the case of ndarrays, the slice operator would take as many start and end combinations as the dimensions of the ndarray. Which means that slicing can be performed for each dimension of a multidimensional ndarray. In the example below, we first create a three dimensional array having values from 0 to 27. Note that the zeroth element of this 3D array is a 2D array (with values 0 to 8). Similarly, the first element of this 3D array is another 2D array (with values 9 to 17). Next, using slicing, we’ll print one of the number of from this 3D array.\n\narray_3d = np.arange(0,27).reshape(3,3,3)\nprint(array_3d)\n\n[[[ 0  1  2]\n  [ 3  4  5]\n  [ 6  7  8]]\n\n [[ 9 10 11]\n  [12 13 14]\n  [15 16 17]]\n\n [[18 19 20]\n  [21 22 23]\n  [24 25 26]]]\n\n\n\nprint(array_3d.shape)\nprint(array_3d[0,2,1])\n\n(3, 3, 3)\n7\n\n\n\nThe figure below shows the parsing of the slice operator for the 3D array.\n<img src=\"ndarray_3D.PNG\" width=50%, align=\"left\">\n\n\nprint(array_3d[:,:,0])\n\n[[ 0  3  6]\n [ 9 12 15]\n [18 21 24]]\n\n\n\nQuiz: What would be the slice operator for array_3d to get the following output  [[[10 11]    [13 14]]   [[19 20]    [22 23]]] \n\n\n\nShow answer\nprint(array_3d[1:3,:2,1:3])"
  },
  {
    "objectID": "Numpy.html#combining-arrays",
    "href": "Numpy.html#combining-arrays",
    "title": "10  NumPy",
    "section": "10.4 Combining arrays",
    "text": "10.4 Combining arrays\nThe Numpy arrays can be combined using concatenate function. All the arrays that are to be combined must have same number of dimensions. The arrays to be joined as passed as a tuple and an axis can be specified to indicate the direction along which to join the arrays. The arrays can be joined along row-wise or column-wise by specifing axis as 0 or 1, respectively. Note that the dimensions for all the arrays along the concatenation axis must be identical. That is to say that, e.g., when combining two or more arrays along rows - the number of rows in all the arrays should be same.\n\nprint(np.arange(1,5))\n\n[1 2 3 4]\n\n\n\narr1 = np.arange(1,5).reshape(2,2)\narr2 = np.array([[5,6]]) #note the square brackets\n\nprint(arr1.shape)\nprint(arr2.shape)\n\n(2, 2)\n(1, 2)\n\n\n\narr3 = np.concatenate((arr1,arr2), axis=0) \nprint(arr3)\n\n[[1 2]\n [3 4]\n [5 6]]\n\n\nThe above code won’t work with axis=1 because the number of rows in the two arrays is not same. We can transpose the arr2 and then concatenate it with arr1 along axis=1.\n\narr4 = np.concatenate((arr1, arr2.T), axis=1) #note the .T\nprint(arr4)\n\n[[1 2 5]\n [3 4 6]]\n\n\nSimilar, output can be generated using the vstack and hstack functions as shown below.\n\nprint(np.vstack((arr1,arr2)))\nprint(np.hstack((arr1,arr2.T)))\n\n[[1 2]\n [3 4]\n [5 6]]\n[[1 2 5]\n [3 4 6]]"
  },
  {
    "objectID": "Numpy.html#broadcasting",
    "href": "Numpy.html#broadcasting",
    "title": "10  NumPy",
    "section": "10.5 Broadcasting",
    "text": "10.5 Broadcasting\nWhen performing arithmetic operations with arrays of different sizes, numpy has a an efficient way of broadcasting the array with lower dimensions to match the dimensions of larger array. Broadcasting can be thought of as creating replicas of the original array. This vectorized array operation is a lot faster than conventional looping in Python.\n\narr1 = np.arange(1,5).reshape(2,2)\narr2 = np.array([[5,6]]) #note the square brackets\nprint(arr1)\nprint(arr2)\n\n[[1 2]\n [3 4]]\n[[5 6]]\n\n\nWhen we multiply the two arrays (arr1 * arr2) the arr2 would be broadcasted such as its shape would change from (1,2) to (2,2). Now, with this broadcasted array the multiplication would be performed element-wise. Similarly, when with multiple a scaler with a ndarray, the scaler is broadcasted to match the dimensions of the ndarray followed by element-wise multiplication.\n\nprint(arr1*arr2) #arr2 would be broadcasted along rows\n\n[[ 5 12]\n [15 24]]\n\n\n\nprint(arr1*arr2.T) #arr2 would be broadcasted along columns\n\n[[ 5 10]\n [18 24]]\n\n\n\nprint(arr1*2)\n\n[[2 4]\n [6 8]]\n\n\n\nQuiz: Write a program to calculate cube of first 10 natural numbers.\n\n\n\nShow answer\nprint(np.arange(1,11)**3)\n\n\nThis ability to broadcast open up lot of possibilities when working with martices. A simple example is shown be to print table for first ten natural numbers.\n\nnum1 = np.arange(1,11).reshape(1,10)\nall_ones = np.ones((10,10), dtype=int)\ntable_10 = all_ones*num1*num1.T\nprint(table_10)\n\n[[  1   2   3   4   5   6   7   8   9  10]\n [  2   4   6   8  10  12  14  16  18  20]\n [  3   6   9  12  15  18  21  24  27  30]\n [  4   8  12  16  20  24  28  32  36  40]\n [  5  10  15  20  25  30  35  40  45  50]\n [  6  12  18  24  30  36  42  48  54  60]\n [  7  14  21  28  35  42  49  56  63  70]\n [  8  16  24  32  40  48  56  64  72  80]\n [  9  18  27  36  45  54  63  72  81  90]\n [ 10  20  30  40  50  60  70  80  90 100]]\n\n\n\n#Print as seen in math books\nfor x in num1[0]:\n    for y in num1[0]:\n        print(f\"{x} X {y} = {table_10[x-1,y-1]}\")\n\n1 X 1 = 1\n1 X 2 = 2\n1 X 3 = 3\n1 X 4 = 4\n1 X 5 = 5\n1 X 6 = 6\n1 X 7 = 7\n1 X 8 = 8\n1 X 9 = 9\n1 X 10 = 10\n2 X 1 = 2\n2 X 2 = 4\n2 X 3 = 6\n2 X 4 = 8\n2 X 5 = 10\n2 X 6 = 12\n2 X 7 = 14\n2 X 8 = 16\n2 X 9 = 18\n2 X 10 = 20\n3 X 1 = 3\n3 X 2 = 6\n3 X 3 = 9\n3 X 4 = 12\n3 X 5 = 15\n3 X 6 = 18\n3 X 7 = 21\n3 X 8 = 24\n3 X 9 = 27\n3 X 10 = 30\n4 X 1 = 4\n4 X 2 = 8\n4 X 3 = 12\n4 X 4 = 16\n4 X 5 = 20\n4 X 6 = 24\n4 X 7 = 28\n4 X 8 = 32\n4 X 9 = 36\n4 X 10 = 40\n5 X 1 = 5\n5 X 2 = 10\n5 X 3 = 15\n5 X 4 = 20\n5 X 5 = 25\n5 X 6 = 30\n5 X 7 = 35\n5 X 8 = 40\n5 X 9 = 45\n5 X 10 = 50\n6 X 1 = 6\n6 X 2 = 12\n6 X 3 = 18\n6 X 4 = 24\n6 X 5 = 30\n6 X 6 = 36\n6 X 7 = 42\n6 X 8 = 48\n6 X 9 = 54\n6 X 10 = 60\n7 X 1 = 7\n7 X 2 = 14\n7 X 3 = 21\n7 X 4 = 28\n7 X 5 = 35\n7 X 6 = 42\n7 X 7 = 49\n7 X 8 = 56\n7 X 9 = 63\n7 X 10 = 70\n8 X 1 = 8\n8 X 2 = 16\n8 X 3 = 24\n8 X 4 = 32\n8 X 5 = 40\n8 X 6 = 48\n8 X 7 = 56\n8 X 8 = 64\n8 X 9 = 72\n8 X 10 = 80\n9 X 1 = 9\n9 X 2 = 18\n9 X 3 = 27\n9 X 4 = 36\n9 X 5 = 45\n9 X 6 = 54\n9 X 7 = 63\n9 X 8 = 72\n9 X 9 = 81\n9 X 10 = 90\n10 X 1 = 10\n10 X 2 = 20\n10 X 3 = 30\n10 X 4 = 40\n10 X 5 = 50\n10 X 6 = 60\n10 X 7 = 70\n10 X 8 = 80\n10 X 9 = 90\n10 X 10 = 100"
  },
  {
    "objectID": "Matplotlib.html",
    "href": "Matplotlib.html",
    "title": "11  Matplotlib",
    "section": "",
    "text": "Matplotlib is a Python library for data visualization. It offers variety of functions to plot different types of graphs which can be customised to create high quality figures. The pyplot function in this library is used for instantiating a matplotlib graph object. The plot function draws a line plot given two sequences of equal length. The get the scatter plot use scatter. Properties such as line-width, line-color, marker-type, etc. can be easily customized using the appropriate keyword arguments. The pyplot object also has functions for decorating the plots with axis-labels, title, text, legend, etc. The show function renders the plot.\nThe image below shows the different customizable elements in a matplotlib figure. These elements are accessible via different function available for the pyplot object or the axes object. The axes object is accessible through the gca function for the pyplot object. As shown above the axes label can be changed using the xlabel and ylabel for the pyplot object.\nImage source - https://matplotlib.org.\nTo change the x-axis ticks there is no direct way to do this using the pyplot object. So we need to create an axes object to modify x-ticks. The set_ticks function available for the axes.xaxis object can ge used to specify a list having locations for xticks.\nWe can also have multiple plots in one graph i.e. different plots sharing the same axes.\nMatplotlib has a variety of in-built graph types that can be used to display information as required. Below are examples of some of the plots available in matplotlib. The title of these plots represent the corresponding function avaiable for the pyplot object.\nQuiz: Write a program to make a graph as shown below."
  },
  {
    "objectID": "Matplotlib.html#subplots",
    "href": "Matplotlib.html#subplots",
    "title": "11  Matplotlib",
    "section": "11.1 subplots",
    "text": "11.1 subplots\nMany a time we need to plot multiple graphs in one figure for effecient visual analysis. In Matplotlib terminilogy these plots are refered to as subplots. The pyplot class has subplots function that return a figure and and axes object. These can be used to access and manipulated different elements of the graph. In addition, subplots can take as argument the total number of plots to create a figure. This function has a keyword argument figsize to specify the size of the plot.\n\nx = range(1,11)\ny = [a**2 for a in x]\nz = [a**3 for a in x]\n\nfig, ax = plt.subplots(2,1,sharex=True) #two rows and one column\n\nax[0].scatter(x,y,marker=\"^\", color=\"red\")\nax[1].scatter(x,z,marker=\"*\", color=\"purple\")\nax[1].set_xlabel(\"Number\")\nax[0].set_ylabel(\"Squares\")\nax[1].set_ylabel(\"Cubes\")\nplt.show()\n\n\n\n\nThe subplots in the above figure can be stacked horizontally by changing the subplots statement to plt.subplots(1,2).\n\n\n\n\n\nSimilarly, we can create different arrangements for subplots and save an image using savefig function of the figure object. The resolution of the resulting image can be controlled using the dpi argument. The alphaargument in the code below is used to make the bars transparent.\n\nx = range(1,11)\ny = [a**2 for a in x]\nz = [a**3 for a in x]\n\nfig, ax = plt.subplots(2,2) #create subplots with two rows and two columns\nax[0,0].scatter(x,y,marker=\"^\", color=\"red\")\nax[0,1].bar(x,y,color=\"red\")\n\nax[1,0].scatter(x,z,marker=\"*\", color=\"purple\")\nax[1,0].bar(x,z,color=\"purple\",alpha=0.1)\nax[1,1].bar(x,z,color=\"purple\")\n\nfig.savefig(\"subplot.png\", dpi=300)\nplt.show()"
  },
  {
    "objectID": "Matplotlib.html#subplot-without-s",
    "href": "Matplotlib.html#subplot-without-s",
    "title": "11  Matplotlib",
    "section": "11.2 subplot (without ‘s’)",
    "text": "11.2 subplot (without ‘s’)\nThe subplot() function is similar to subplots with a difference that it take an additional argument - index. This can be used to make axes span multiple columns within the subplot.\n\nx = range(1,11)\ny = [a**2 for a in x]\nz = [a**3 for a in x]\n\nax1 = plt.subplot(2,1,1) \nax2 = plt.subplot(2,2,3)\nax3 = plt.subplot(2,2,4)\n\nax1.scatter(x,y,marker=\"^\", color=\"red\")\nax1.bar(x,y, color=\"red\",alpha=0.1)\nax2.scatter(x,z,marker=\"*\", color=\"purple\")\nax3.bar(x,z,color=\"purple\")\n\nplt.savefig(\"subplots2.png\",dpi=300)\nplt.show()"
  },
  {
    "objectID": "Pandas.html",
    "href": "Pandas.html",
    "title": "12  Pandas",
    "section": "",
    "text": "Pandas is a library that is useful for working with different types of datasets. A dataframe is a pandas object that has a variety of function to analyze and visualize data. It arranges the data in rows and columns. There are multiple ways in which a dataframe can be created. For example, a dictionary can be converted to a datafraem such that the keys become headers and values (list) are entries in the dataframe. The orientation of the dataframe by default is columns ie keys are considered as column header and values are rows. This behaviour can be changed using the orient argument. When orientation is index, an addtional argument columns can be used to specify column headers."
  },
  {
    "objectID": "Pandas.html#basic-information-about-the-dataframe",
    "href": "Pandas.html#basic-information-about-the-dataframe",
    "title": "12  Pandas",
    "section": "12.1 Basic information about the dataframe",
    "text": "12.1 Basic information about the dataframe\nPandas offers set of commands to get some basic information about the content of dataframes. Below are some of these command along with their corresponding output.\n\n\n\n\n\n\n\n  \n    \n      \n      Column1\n      Column2\n    \n  \n  \n    \n      0\n      A\n      1\n    \n    \n      1\n      B\n      2\n    \n    \n      2\n      C\n      3\n    \n    \n      3\n      D\n      4\n    \n    \n      4\n      E\n      5\n    \n  \n\n\n\n\nInformation about this dataframe \ndf1.shape      (5, 2)\ndf1.size       10\ndf1.ndim       2\ndf1.values     [['A' 1]\n ['B' 2]\n ['C' 3]\n ['D' 4]\n ['E' 5]]"
  },
  {
    "objectID": "Pandas.html#reading-data-from-a-csv-file",
    "href": "Pandas.html#reading-data-from-a-csv-file",
    "title": "12  Pandas",
    "section": "12.2 Reading data from a csv file",
    "text": "12.2 Reading data from a csv file\nThe read_csv() function can be used to create a dataframe from a csv file. To use one of the columns as indices for the dataframe add the index_col keyword attribute.\n\n# %load test.csv\nName,Age,Country\nSohan,22,India\nSam,21,USA\n\n\ndf3 = pd.read_csv(\"test.csv\")\ndf4 = pd.read_csv(\"test.csv\", index_col=\"Country\")\ndisplay(df3)\ndisplay(df4)\n\n\n\n\n\n\n\n  \n    \n      \n      Name\n      Age\n      Country\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      Name\n      Age\n    \n    \n      Country\n      \n      \n    \n  \n  \n    \n      India\n      Sohan\n      22\n    \n    \n      USA\n      Sam\n      21"
  },
  {
    "objectID": "Pandas.html#combining-dataframes---join-merge-and-concat",
    "href": "Pandas.html#combining-dataframes---join-merge-and-concat",
    "title": "12  Pandas",
    "section": "12.3 Combining dataframes - join, merge, and concat",
    "text": "12.3 Combining dataframes - join, merge, and concat\nConcat is used to combine dataframes across rows or columns. Merge is used to combine dataframes on common columns or indices. Join is used to combine based on a key column or index.\n\nimport numpy as np\ndf_1 = pd.DataFrame(np.random.uniform(1,2,size=(5, 4)), columns=list('ABCD'))\ndf_2 = pd.DataFrame(np.random.uniform(2,3,size=(5, 4)), columns=list('ABCD'))\n\n\ndisplay(df_1)\ndisplay(df_2)\n\n\n\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.356623\n      1.477763\n      1.569974\n      1.778819\n    \n    \n      1\n      1.532714\n      1.464930\n      1.382634\n      1.496065\n    \n    \n      2\n      1.565586\n      1.537660\n      1.558265\n      1.089754\n    \n    \n      3\n      1.526300\n      1.392927\n      1.798358\n      1.181237\n    \n    \n      4\n      1.693383\n      1.225141\n      1.411091\n      1.804210\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      2.246880\n      2.632981\n      2.831306\n      2.088775\n    \n    \n      1\n      2.990886\n      2.369731\n      2.697256\n      2.048426\n    \n    \n      2\n      2.030963\n      2.141273\n      2.001073\n      2.406086\n    \n    \n      3\n      2.295191\n      2.721775\n      2.267560\n      2.300182\n    \n    \n      4\n      2.182948\n      2.941006\n      2.654403\n      2.478437\n    \n  \n\n\n\n\n\n\n\ndf_new = pd.concat([df_1,df_2],ignore_index=True)\ndisplay(df_new)\n\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.356623\n      1.477763\n      1.569974\n      1.778819\n    \n    \n      1\n      1.532714\n      1.464930\n      1.382634\n      1.496065\n    \n    \n      2\n      1.565586\n      1.537660\n      1.558265\n      1.089754\n    \n    \n      3\n      1.526300\n      1.392927\n      1.798358\n      1.181237\n    \n    \n      4\n      1.693383\n      1.225141\n      1.411091\n      1.804210\n    \n    \n      5\n      2.246880\n      2.632981\n      2.831306\n      2.088775\n    \n    \n      6\n      2.990886\n      2.369731\n      2.697256\n      2.048426\n    \n    \n      7\n      2.030963\n      2.141273\n      2.001073\n      2.406086\n    \n    \n      8\n      2.295191\n      2.721775\n      2.267560\n      2.300182\n    \n    \n      9\n      2.182948\n      2.941006\n      2.654403\n      2.478437\n    \n  \n\n\n\n\n\ndf_new = pd.concat([df_1,df_2],axis=1)\ndisplay(df_new)\n\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.356623\n      1.477763\n      1.569974\n      1.778819\n      2.246880\n      2.632981\n      2.831306\n      2.088775\n    \n    \n      1\n      1.532714\n      1.464930\n      1.382634\n      1.496065\n      2.990886\n      2.369731\n      2.697256\n      2.048426\n    \n    \n      2\n      1.565586\n      1.537660\n      1.558265\n      1.089754\n      2.030963\n      2.141273\n      2.001073\n      2.406086\n    \n    \n      3\n      1.526300\n      1.392927\n      1.798358\n      1.181237\n      2.295191\n      2.721775\n      2.267560\n      2.300182\n    \n    \n      4\n      1.693383\n      1.225141\n      1.411091\n      1.804210\n      2.182948\n      2.941006\n      2.654403\n      2.478437\n    \n  \n\n\n\n\n\ndf_new = pd.concat([df_1,df_2],keys=[\"First\",\"Second\"])\ndisplay(df_new)\n\n\n\n\n\n  \n    \n      \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      First\n      0\n      1.356623\n      1.477763\n      1.569974\n      1.778819\n    \n    \n      1\n      1.532714\n      1.464930\n      1.382634\n      1.496065\n    \n    \n      2\n      1.565586\n      1.537660\n      1.558265\n      1.089754\n    \n    \n      3\n      1.526300\n      1.392927\n      1.798358\n      1.181237\n    \n    \n      4\n      1.693383\n      1.225141\n      1.411091\n      1.804210\n    \n    \n      Second\n      0\n      2.246880\n      2.632981\n      2.831306\n      2.088775\n    \n    \n      1\n      2.990886\n      2.369731\n      2.697256\n      2.048426\n    \n    \n      2\n      2.030963\n      2.141273\n      2.001073\n      2.406086\n    \n    \n      3\n      2.295191\n      2.721775\n      2.267560\n      2.300182\n    \n    \n      4\n      2.182948\n      2.941006\n      2.654403\n      2.478437\n    \n  \n\n\n\n\n\ndisplay(df_new.loc[\"First\"])\n\n\n\n\n\n  \n    \n      \n      A\n      B\n      C\n      D\n    \n  \n  \n    \n      0\n      1.356623\n      1.477763\n      1.569974\n      1.778819\n    \n    \n      1\n      1.532714\n      1.464930\n      1.382634\n      1.496065\n    \n    \n      2\n      1.565586\n      1.537660\n      1.558265\n      1.089754\n    \n    \n      3\n      1.526300\n      1.392927\n      1.798358\n      1.181237\n    \n    \n      4\n      1.693383\n      1.225141\n      1.411091\n      1.804210\n    \n  \n\n\n\n\nMerge is used combine dataframe on one or more columns\n\ndf3 = pd.read_csv(\"test.csv\")\n\ndisplay(df3)\ndf4 = df3.copy(deep=True)\ndf4.loc[2]=[\"Peter\", 20, \"UK\"] \ndf4.loc[len(df4.index)] = [\"Mohan\", 25, \"India\"]\ndisplay(df4)\n\ndf_merged1 = pd.merge(df3,df4)\ndisplay(df_merged1)\n\ndf_merged2 = pd.merge(df3,df4,on=[\"Country\",\"Name\"],\\\n                      suffixes=('_df3', '_df4'))\ndisplay(df_merged2)\n\n\n\n\n\n\n\n\n  \n    \n      \n      \n      df3\n      \n    \n    \n      \n      Name\n      Age\n      Country\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      df4\n    \n    \n      \n      Name\n      Age\n      Country\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n    \n    \n      2\n      Peter\n      20\n      UK\n    \n    \n      3\n      Mohan\n      25\n      India\n    \n  \n\n\n\n\n\n\n\n\n\n\n  \n    \n      \n      df_merged1\n    \n    \n      \n      Name\n      Age\n      Country\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      df_merged2\n    \n    \n      \n      Name\n      Age_df3\n      Country\n      Age_df4\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n      22\n    \n    \n      1\n      Sam\n      21\n      USA\n      21\n    \n  \n\n\n\n\n\nJoin is used to combine dataframes along a specific column.\n\ndisplay(df3.join(df4,lsuffix='_df3', rsuffix='_df4'))\n\n\n\n\n\n  \n    \n      \n      Name_df3\n      Age_df3\n      Country_df3\n      Name_df4\n      Age_df4\n      Country_df4\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n      Sam\n      21\n      USA\n    \n  \n\n\n\n\n\ndisplay(df3)\n\n\n\n\n\n  \n    \n      \n      Name\n      Age\n      Country\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n    \n    \n      1\n      Sam\n      21\n      USA\n    \n  \n\n\n\n\n\ndisplay(df3.join(df4.set_index(\"Country\"),on=\"Country\", lsuffix='_df3', rsuffix='_df4'))\n\n\n\n\n\n  \n    \n      \n      Name_df3\n      Age_df3\n      Country\n      Name_df4\n      Age_df4\n    \n  \n  \n    \n      0\n      Sohan\n      22\n      India\n      Sohan\n      22\n    \n    \n      0\n      Sohan\n      22\n      India\n      Mohan\n      25\n    \n    \n      1\n      Sam\n      21\n      USA\n      Sam\n      21\n    \n  \n\n\n\n\n\ndisplay(df3.join(df4.set_index(\"Country\"),on=\"Country\", lsuffix='_df3', rsuffix='_df4', how=\"outer\"))\n\n\n\n\n\n  \n    \n      \n      Name_df3\n      Age_df3\n      Country\n      Name_df4\n      Age_df4\n    \n  \n  \n    \n      0.0\n      Sohan\n      22.0\n      India\n      Sohan\n      22\n    \n    \n      0.0\n      Sohan\n      22.0\n      India\n      Mohan\n      25\n    \n    \n      1.0\n      Sam\n      21.0\n      USA\n      Sam\n      21\n    \n    \n      NaN\n      NaN\n      NaN\n      UK\n      Peter\n      20"
  },
  {
    "objectID": "Pandas.html#groupby",
    "href": "Pandas.html#groupby",
    "title": "12  Pandas",
    "section": "12.4 Groupby",
    "text": "12.4 Groupby\nWe can create groups for same values in a column to apply a function to all rows having a particular value.\n\nstudents = [[\"Sam\",\"Peter\",\"Mohan\", \"Mike\"], [\"UG\",\"PG\",\"UG\",\"PG\"], [70,80,90,70]]\ndf_students = pd.DataFrame(students).T\n\ndf_students.columns=[\"Name\",\"Program\",\"Marks\"]\ndisplay(df_students)\n\n\n\n\n\n  \n    \n      \n      Name\n      Program\n      Marks\n    \n  \n  \n    \n      0\n      Sam\n      UG\n      70\n    \n    \n      1\n      Peter\n      PG\n      80\n    \n    \n      2\n      Mohan\n      UG\n      90\n    \n    \n      3\n      Mike\n      PG\n      70\n    \n  \n\n\n\n\n\ndf_students.set_index(\"Program\", inplace=True)\ndisplay(df_students)\n\n\n\n\n\n  \n    \n      \n      Name\n      Marks\n    \n    \n      Program\n      \n      \n    \n  \n  \n    \n      UG\n      Sam\n      70\n    \n    \n      PG\n      Peter\n      80\n    \n    \n      UG\n      Mohan\n      90\n    \n    \n      PG\n      Mike\n      70\n    \n  \n\n\n\n\n\ndf_students.groupby(level=\"Program\")[\"Marks\"].mean()\n\nProgram\nPG    75.0\nUG    80.0\nName: Marks, dtype: float64\n\n\n\n12.4.1 Ploting\nDataframe has a plot() function to do basic visualization. The kind attribute for this function can be used to change the plot type.\n\ndf_col1 = pd.DataFrame(np.array(range(1,6))**2)\ndf_col2 = pd.DataFrame(np.array(range(1,6))**3)\n\ndf_comb = pd.concat([df_col1,df_col2], axis=1, ignore_index=True)\ndf_comb.columns = [\"Squares\", \"Cubes\"]\ndf_comb.index = range(1,6)\ndisplay(df_comb)\n\n\n\n\n\n  \n    \n      \n      Squares\n      Cubes\n    \n  \n  \n    \n      1\n      1\n      1\n    \n    \n      2\n      4\n      8\n    \n    \n      3\n      9\n      27\n    \n    \n      4\n      16\n      64\n    \n    \n      5\n      25\n      125\n    \n  \n\n\n\n\n\nplot1 = df_comb.plot(title=\"Line Plot\")\nplot2 = df_comb.plot(kind=\"bar\", title=\"Bar Plot\")"
  },
  {
    "objectID": "Pandas.html#the-iris-dataset",
    "href": "Pandas.html#the-iris-dataset",
    "title": "12  Pandas",
    "section": "12.5 The iris dataset",
    "text": "12.5 The iris dataset\n\ncsv_url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'\n# using the attribute information as the column names\ncol_names = ['Sepal_Length','Sepal_Width','Petal_Length','Petal_Width','Class']\niris =  pd.read_csv(csv_url, names = col_names)\n\n\niris\n\n\n\n\n\n  \n    \n      \n      Sepal_Length\n      Sepal_Width\n      Petal_Length\n      Petal_Width\n      Class\n    \n  \n  \n    \n      0\n      5.1\n      3.5\n      1.4\n      0.2\n      Iris-setosa\n    \n    \n      1\n      4.9\n      3.0\n      1.4\n      0.2\n      Iris-setosa\n    \n    \n      2\n      4.7\n      3.2\n      1.3\n      0.2\n      Iris-setosa\n    \n    \n      3\n      4.6\n      3.1\n      1.5\n      0.2\n      Iris-setosa\n    \n    \n      4\n      5.0\n      3.6\n      1.4\n      0.2\n      Iris-setosa\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      145\n      6.7\n      3.0\n      5.2\n      2.3\n      Iris-virginica\n    \n    \n      146\n      6.3\n      2.5\n      5.0\n      1.9\n      Iris-virginica\n    \n    \n      147\n      6.5\n      3.0\n      5.2\n      2.0\n      Iris-virginica\n    \n    \n      148\n      6.2\n      3.4\n      5.4\n      2.3\n      Iris-virginica\n    \n    \n      149\n      5.9\n      3.0\n      5.1\n      1.8\n      Iris-virginica\n    \n  \n\n150 rows × 5 columns\n\n\n\n\nprint(\"Shape\", iris.shape)\nprint(iris.dtypes)\n\nShape (150, 5)\nSepal_Length    float64\nSepal_Width     float64\nPetal_Length    float64\nPetal_Width     float64\nClass            object\ndtype: object\n\n\n\niris.describe()\n\n\n\n\n\n  \n    \n      \n      Sepal_Length\n      Sepal_Width\n      Petal_Length\n      Petal_Width\n    \n  \n  \n    \n      count\n      150.000000\n      150.000000\n      150.000000\n      150.000000\n    \n    \n      mean\n      5.843333\n      3.054000\n      3.758667\n      1.198667\n    \n    \n      std\n      0.828066\n      0.433594\n      1.764420\n      0.763161\n    \n    \n      min\n      4.300000\n      2.000000\n      1.000000\n      0.100000\n    \n    \n      25%\n      5.100000\n      2.800000\n      1.600000\n      0.300000\n    \n    \n      50%\n      5.800000\n      3.000000\n      4.350000\n      1.300000\n    \n    \n      75%\n      6.400000\n      3.300000\n      5.100000\n      1.800000\n    \n    \n      max\n      7.900000\n      4.400000\n      6.900000\n      2.500000\n    \n  \n\n\n\n\n\niris.set_index(\"Class\").groupby(level=\"Class\").describe()\n\n\n\n\n\n  \n    \n      \n      Sepal_Length\n      Sepal_Width\n      ...\n      Petal_Length\n      Petal_Width\n    \n    \n      \n      count\n      mean\n      std\n      min\n      25%\n      50%\n      75%\n      max\n      count\n      mean\n      ...\n      75%\n      max\n      count\n      mean\n      std\n      min\n      25%\n      50%\n      75%\n      max\n    \n    \n      Class\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Iris-setosa\n      50.0\n      5.006\n      0.352490\n      4.3\n      4.800\n      5.0\n      5.2\n      5.8\n      50.0\n      3.418\n      ...\n      1.575\n      1.9\n      50.0\n      0.244\n      0.107210\n      0.1\n      0.2\n      0.2\n      0.3\n      0.6\n    \n    \n      Iris-versicolor\n      50.0\n      5.936\n      0.516171\n      4.9\n      5.600\n      5.9\n      6.3\n      7.0\n      50.0\n      2.770\n      ...\n      4.600\n      5.1\n      50.0\n      1.326\n      0.197753\n      1.0\n      1.2\n      1.3\n      1.5\n      1.8\n    \n    \n      Iris-virginica\n      50.0\n      6.588\n      0.635880\n      4.9\n      6.225\n      6.5\n      6.9\n      7.9\n      50.0\n      2.974\n      ...\n      5.875\n      6.9\n      50.0\n      2.026\n      0.274650\n      1.4\n      1.8\n      2.0\n      2.3\n      2.5\n    \n  \n\n3 rows × 32 columns\n\n\n\n\nplot3 = iris.plot.scatter(x=\"Sepal_Length\",y=\"Sepal_Width\")\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\nplot4 = iris.set_index(\"Class\").groupby(level=\"Class\").plot.scatter(x=\"Sepal_Length\",y=\"Petal_Length\")\n\n\n\n\n\n\n\n\n\n\n\nplot5 = sns.jointplot(data=iris,x=\"Sepal_Length\",y=\"Petal_Length\",hue=\"Class\")"
  },
  {
    "objectID": "Functions.html",
    "href": "Functions.html",
    "title": "13  Functions",
    "section": "",
    "text": "In programming when a sub-set of code is to be execute in one go, we have an option to give a name to that sub-set and that name is now a function. As an analogy consider the steps in making tea.\nThe above steps need to done everytime we make tea. Also, we can create a new sub-set with some customization — “Make Tea with options”. So, whenever we say “make tea” it is implied that the step mentioned above would be performed and we don’t need to mention the steps again; just make tea is enough. Similarly, in programming we can assign a keyword to a code block such that every time that keyword is called all the code within that block gets executed. Contining with our analogy, we now have two “functions” – “Make Tea” and “Make Tea with options”.\nSo far we have used various in-built Python functions. Now lets look at how we can define our own functions to do a specific task. To define a function, def keyword is used followed by a function name and parenthesis. The def statement ends with a colon and the statement within the function are indented (a syntax similar to for and if statements). A function can be initialized with or without arguments. To call a function, specify the function name along with parenthesis. Below is a “Hello world!” function.\nThe argument(s) that a function takes goes inside the parenthesis when defining the function. An argument can be positional i.e. it must be specificed in a particular sequence or it can be a keyword argument (these can be specified in any order). An important point to note about functions is that the variables within a function have a local scope i.e. a variable declared within a function cannot be accessed outside the function. So, lets say we have a function that does some calculation and we would like to get the result of that calculation. In such cases we need to return the variable(s) using the return keyword. When calling the function these returned values are assigned to specified variables. Below is an example of a function with two positional arguments. Notice that when call this function the order of argument is important."
  },
  {
    "objectID": "Functions.html#arguments",
    "href": "Functions.html#arguments",
    "title": "13  Functions",
    "section": "13.1 Arguments",
    "text": "13.1 Arguments\n\ndef calcPower(a,b):\n    c = a**b\n    return c\noutput_1 = calcPower(3,4)\nprint(output_1)\noutput_2 = calPower(4,3)\nprint(output_2)\n\n81\n64"
  },
  {
    "objectID": "Functions.html#keyword-arguments",
    "href": "Functions.html#keyword-arguments",
    "title": "13  Functions",
    "section": "13.2 Keyword arguments",
    "text": "13.2 Keyword arguments\nWe can have the same funtion with keyword arguments such that now the arguments can be specified in any order. All keyword arguments need to have a default value. If a value for a keyword argument is not specified while calling the function, the default value of the keyword is used.\n\ndef calcPower(number=1,power=1):\n    c = number**power\n    return c\noutput_1 = calcPower(power=3,number=4)\nprint(output_1)\n\n64\n\n\nIt is important to note here that keyword arguments can be specified without keyword as well when calling a function. In this case the order of arguments passed would be matched to the order of the keywords in the function definition.\n\ncalcPower(2,3)\n\n8"
  },
  {
    "objectID": "Functions.html#variable-number-of-arguments",
    "href": "Functions.html#variable-number-of-arguments",
    "title": "13  Functions",
    "section": "13.3 Variable number of arguments",
    "text": "13.3 Variable number of arguments\nA function can have both positional and keyword arguments and in such case the keyword arguments must be specified after positional arguments.\nIt is also possible to have arbitrary number of positional and keyword arguments. The *args argument maintains a tuple named args that stores all the arguments passed when a function is called.\n\ndef sumNums(*args):\n    '''This function would add any set of numbers.\n    It has been defined using *args.'''\n    c = 0\n    for num in args:\n        c = c+num\n    return c\nprint(sumNums(4,5,6))\n\n15\n\n\nThe tripple quoted string in the above function not only acts a comment but is also available as help for this function accessible via help function.\n\nhelp(sumNums)\n\nHelp on function sumNums in module __main__:\n\nsumNums(*args)\n    This function would add any set of numbers.\n    It has been defined using *args.\n\n\n\n\nQuiz: Write a function to calculate (a + b)2.\n\n\n\nShow answer\ndef squareSum(a,b):\n    c = a**2 + b**2 + 2*a*b\n    return c\nnum1 = 4\nnum2 = 5\nprint(f\"The square of sum of {num1} and {num2} is {squareSum(num1,num2)}.\")"
  },
  {
    "objectID": "Functions.html#variable-number-of-keyword-arguments",
    "href": "Functions.html#variable-number-of-keyword-arguments",
    "title": "13  Functions",
    "section": "13.4 Variable number of keyword arguments",
    "text": "13.4 Variable number of keyword arguments\nThe **kwargs argument is used to have an arbitrary number of keyword arguments. Note the two asterisks. In this case, a kwargs dictionary is maintained which as the keyword and its value as key-value pairs of the dictionary.\n\ndef func1(**kwargs):\n    all_keywords = kwargs.keys()\n    all_values = kwargs.values()\n    return all_keywords, all_values\nk1,v1 = func1(name=\"Sam\", age=20)\nprint(k1)\nprint(v1)\n\ndict_keys(['name', 'age'])\ndict_values(['Sam', 20])"
  },
  {
    "objectID": "Functions.html#reusing-functions",
    "href": "Functions.html#reusing-functions",
    "title": "13  Functions",
    "section": "13.5 Reusing functions",
    "text": "13.5 Reusing functions\nFunction is a python file can be accessed in another python code. E.g., we have a file fileA.py that has function funcInFileA. Now to call this function from FileB.py we need to import this function — from fileA import funcInFileA.\n\n\n\n\n\n\nRecommendation\n\n\n\nTo practice function import it is advisable to do it on a console rather than inside notebook.\n\n\n\n# fileA.py\ndef funcInFileA():\n    print(\"Inside File A\")\n\n\n#fileB.py\nfrom fileA import funcInFileA\nfuncInFileA()\n\nInside File A\n\n\nSave the above two files in the same folder and then execute fileB.py. If we execute file fileA.py then there would be no output since we are not calling the function funcInFileA in that file. In case we do call funcInFileA in fileA.py then this function would be called twice upon calling from fileB.py.\nIf you would like to have an option to call funcInFileA from both the files and prevent calling it twice when importing this function then you need to use a special variable called __name__ (note the two underscores at the begining and the end). This variable stores the name of the module being executed. Each python file or a module has a __name__ variable associated with it. When a python file is executed this variable is assigned a value __main__.\n\nprint(__name__)\n\n__main__\n\n\nHere the value is __main__ because we are executing the code directly. When we import a function then value of the __name__ variable is set to the filename in which we have the imported function. So the recommend way to call funcInFileA would be to first check the value of __name__ followed by conditional calling. At the end of fileA.py we can the following code.\n\n#Add this to fileA.py\nif __name__ == \"__main__\":\n    funcInFileA()\n\nNow, the function is called when we execute either of the files. Upon executing fileB.py, since the function is imported, the __name__ variable for fileA would not be equal to __main__ and hence would not be called because the if condition there would be false."
  },
  {
    "objectID": "BioPython_Intro.html",
    "href": "BioPython_Intro.html",
    "title": "14  Introduction to BioPython",
    "section": "",
    "text": "Python offers a variety of functions to work with text data (Strings) that in turn make it easier to work with biological data such as DNA or protein sequences. BioPython library provides a set of classes dedicated to parsing and analysis of different type of biological data. The functions avaiable in BioPython helps researcher to progammatically process the data. Below we’ll see some of the features in Biopython for working with biological data.\nTo install Biopython library run pip install biopython. For more details regarding Biopython installation and tutorials, please refer to the Biopython wiki.\nTo check the version of Biopython, run the following command."
  },
  {
    "objectID": "BioPython_Intro.html#sequence-object",
    "href": "BioPython_Intro.html#sequence-object",
    "title": "14  Introduction to BioPython",
    "section": "14.1 Sequence Object",
    "text": "14.1 Sequence Object\nTo work with sequences, we’ll need the Bio.Seq class which has the required functions for reading and writing sequence data. Once we have imported this class we can create objects having required data. The example below shows constructing a sequence object with a DNA sequence and then using the complement and translate functions to find the sequence of the complementary strand and the translated protein sequence, respectively.\n\nfrom Bio.Seq import Seq\nnew_sequence = Seq('AATTGGAACCTT')\nprint(new_sequence)\nprint(new_sequence.complement())\nprint(new_sequence.translate())\n\nAATTGGAACCTT\nTTAACCTTGGAA\nNWNL\n\n\nTo create a sequence object by reading sequence from a file, we can use the SeqIO class. The parse function in this class can read and write sequences in different formats. This function take two arguments - file name and format, and return an iterator having all the sequences. The code below shows reading a file having multiple sequences and printing the sequences using the seq attribute. Note that this would print sequnces without any annotations. The description attribute of SeqIO object can used to print the description of a sequence as given in the input file. In the code below, the output would be restricted to first three sequences. If you need to print the data for all sequences then remove the if block. The sequence file used in the code below is available here.\n\nfrom Bio import SeqIO\ncount=0\nfor all_seqs in SeqIO.parse(\"kinases.txt\", \"fasta\"):\n    print(all_seqs.description)\n    print(all_seqs.seq)\n    count += 1\n    if(count == 3):\n        break\n\nconsensus seq\nYELLKVL-GKGAFGE--------------------------------------------------------------------V-Y---KAR-D-----------KD-------------------T------G-----E--E--VAVKV----LK-K---G----E-SS----------------K--K-R--K-------------E-------F-LR-EIKI-LKK------L------------------R--------H---PNIVRLYGVF-----------Q-----E-D----------E----D----P----LY--------LVME-YM-------P-GG----SLFD---L---L-R---K--R---R------------------------------------------------------------------------------G-------L-------S-E-------KTLRFIAAQIASGLEYLH-S-K-GI---------IHRDLKPENIL---L--------D--------------------------S------------------D-G-HVKLADF---GL---AR-----------E-----------L-Y----------S---D-------D---------------------------------G-Y--R-------------------T----------T-----T-FVG-T----P-------------------RY--MAPEV--L---------L-------G-------------GG--Y-SKKSDVWSL---GVLLYELLTG---------G--K---P-----P-F------P----G-E-------S---------------NE---E----LL----E-----------KIL------K---------------------G--------------------Y----------------------R---------------------L---P-I-P---E--P----D----C-----S-----P--E---AK---DLIKK--------CLQK-DPEKRPT\nsp|Q22RR1||agc:agc-sar|Tetrahymena sp|Q22RR1||agc:agc-sar|Tetrahymena\nLVYIKEL-GRGNFGS--------------------------------------------------------------------V-N---LVN-E-----------KQ-------------------K------D-----R--L--FAMKV----FI-S---N----Y-IFqr--------------G--I-E--K-------------Y-------I-LR-EKST-LQK------C------------------N--------F---PFIMRYYRSF-----------Y-------D----------N----Y----H----IY--------FMNE-FI-------N-GM----DFFT---V---M-R---E--V---G------------------------------------------------------------------------------L-------F-------N-K-------QQAQFYTAFIILTLQYLN-N-Q-GI---------VYRDLKPENIL---I--------D--------------------------H------------------E-G-WPKLVDM---GT---AK-----------Y-----------L------------Y---D-------Kn--------------------------------Q-Q--L-------------------T----------Rty---S-LVG-T----P-------------------HY--MAPEV--I---------Q-------Q-------------KG--Y-GFAVDIYSL---GVILYELLV----------G--Y---L-----P-Y------Ged--V-D-------D---------------PI---E----VY----Q-----------LIL------E---------------------G-------------------------------------------R---------------------L---G-F-P---N--H----M----K-----N-----R--L---SK---KLISQ--------LMAK-SPEVRLG\nsp|Q234E6||agc:agc-sar|Tetrahymena sp|Q234E6||agc:agc-sar|Tetrahymena\nLIVIKKL-GFGQFGS--------------------------------------------------------------------V-F---LVK-E-----------KG-------------------K------K-----K--L--YGLKC----VS-K---A----Q-VVeq--------------S--L-E--K-------------H-------I-QN-EKQV-MEF------N------------------N--------F---PFVMKFLRSF-----------K-------D----------D----R----C----IY--------FLLE-FI-------Q-GM----ELFD---V---I-R---E--I---G------------------------------------------------------------------------------L-------L-------S-T-------YDSQFYIGSLILTLEYLH-S-N-YI---------IYRDIKPENIM---V--------D--------------------------H------------------A-G-YLKLIDM---GT---AK-----------I-----------M------------K---S-------Ka--------------------------------G-T--V-------------------T----------Rtf---T-IIG-T----P-------------------HY--MAPEV--I---------S-------G-------------KG--Y-NFLVDLWSV---GICLYEFMC----------G--Y---V-----P-F------Aee--A-E-------D---------------PY---E----IY----E-----------EII------K---------------------K-------------------------------------------E---------------------I---Q-F-P---A--Y----M----K-----D-----A--V---AK---QLMLQ--------LLNK-IPEIRLG"
  },
  {
    "objectID": "BioPython_Intro.html#writing-sequences",
    "href": "BioPython_Intro.html#writing-sequences",
    "title": "14  Introduction to BioPython",
    "section": "14.2 Writing sequences",
    "text": "14.2 Writing sequences\nThe write function takes three arguments — 1) a sequence object, 2) filename, and 3) file format. The code below reads a fasta file with multiple sequences and then save the first 10 sequences in a new file.\n\nall_seqs = []\nfor seq_record in SeqIO.parse(\"kinases.txt\", \"fasta\"):\n    all_seqs.append(seq_record)\nprint(len(all_seqs))\n\nSeqIO.write(all_seqs[0:10],\"test.aln\",\"clustal\")\n\n5489\n\n\n10"
  },
  {
    "objectID": "BioPython_Intro.html#multiple-sequence-alignment",
    "href": "BioPython_Intro.html#multiple-sequence-alignment",
    "title": "14  Introduction to BioPython",
    "section": "14.3 Multiple Sequence Alignment",
    "text": "14.3 Multiple Sequence Alignment\nThe AlignIO class has functions to parse alignment files. The read and write functions have a similar syntax to the corresponding functions in the SeqIO class. The alignment object stores sequences in 2D array format such that the rows are number of sequences and columns represent alignment length. To extract a sub-set of an alignment, slicing feature can be used. The code below shows reading an alignment file in fasta format followed by selecting a portion of this alignment and save it in a new file in clustal format. The subset is extracted by giving the range for the rows and columns within square brackets. The numbering for both rows and columns starts from zero. In the example below first ten sequences in the alignment are selected since range of rows is :10 and the colums range is 3:12.\n\nfrom Bio import AlignIO\nalign1 = AlignIO.read(\"kinases.txt\", \"fasta\")\n\n# slicing - [row range, col range]\nx = align1[:10,3:12]\nprint(x)\nAlignIO.write(x,\"msa1.aln\",\"clustal\")\n\nAlignment with 10 rows and 9 columns\nLKVL-GKGA consensus\nIKEL-GRGN sp|Q22RR1||agc:agc-sar|Tetrahymena\nIKKL-GFGQ sp|Q234E6||agc:agc-sar|Tetrahymena\nVKKL-GNGQ sp|Q23KG5||agc:agc-sar|Tetrahymena\nIKTL-AFGQ sp|Q23DN8||agc:agc-sar|Tetrahymena\nIKKL-GVGQ sp|I7MFS4||agc:agc-sar|Tetrahymena\nIKKL-GFGQ sp|I7M3B5||agc:agc-sar|Tetrahymena\nIKKL-GFGQ sp|I7MD55||agc:agc-sar|Tetrahymena\nIKKL-GEGQ sp|Q869J9|pkg-2|agc:pkg|Paramecium\nIRVL-GKGC sp|A8N3F0||agc:agc-unique|Coprinopsis\n\n\n1\n\n\n\n# %load msa1.aln\nCLUSTAL X (1.81) multiple sequence alignment\n\n\nconsensus                           LKVL-GKGA\nsp|Q22RR1||agc:agc-sar|Tetrahy      IKEL-GRGN\nsp|Q234E6||agc:agc-sar|Tetrahy      IKKL-GFGQ\nsp|Q23KG5||agc:agc-sar|Tetrahy      VKKL-GNGQ\nsp|Q23DN8||agc:agc-sar|Tetrahy      IKTL-AFGQ\nsp|I7MFS4||agc:agc-sar|Tetrahy      IKKL-GVGQ\nsp|I7M3B5||agc:agc-sar|Tetrahy      IKKL-GFGQ\nsp|I7MD55||agc:agc-sar|Tetrahy      IKKL-GFGQ\nsp|Q869J9|pkg-2|agc:pkg|Parame      IKKL-GEGQ\nsp|A8N3F0||agc:agc-unique|Copr      IRVL-GKGC"
  },
  {
    "objectID": "BioPython_Intro.html#running-blast-over-the-internet",
    "href": "BioPython_Intro.html#running-blast-over-the-internet",
    "title": "14  Introduction to BioPython",
    "section": "14.4 Running BLAST over the internet",
    "text": "14.4 Running BLAST over the internet\nBiopython offers a functionality to programmatically run BLAST on the NCBI servers using the Bio.Blast class. To run blast online at NCBI servers, Bio.Blast can be used which has different function to run Blast and also to parse the output. The NCBIWWW library has qblast function that takes three arguments &emdash; 1) blast program (blastp, blastn, etc.), 2) database (any of the databases available at NCBI, and 3) sequence. Once the blast serach is over the output can be saved in a file. This output would be in XML format. We can use the read function within the NCBIXML class to parse this output. The code below shows running a blast search using qblast against the non-redundant database available at in NCBI. The output file saved in the previous step has all the hits identified in the Blast search. These hits follow a hierarchical manner such that each result would have multiple alignments and within each alignment would be multiple high scoring pairs (hsps) i.e. Blast object \\(\\longrightarrow\\) Alignment \\(\\longrightarrow\\) hsps. For more details on this you may refer to the Blast documentation available at NCBI.\n\nfrom Bio.Blast import NCBIWWW\nfrom Bio.Blast import NCBIXML\n\nresult_ncbi = NCBIWWW.qblast(\"blastn\", \"nt\", \"8332116\")\n\nwith open(\"my_blast.xml\", \"w\") as file_handle:\n    file_handle.write(result_ncbi.read())\n\n\nresult_handle = open(\"my_blast.xml\")\nblast_record = NCBIXML.read(result_handle)\ncount = 0\nfor alignment in blast_record.alignments:\n    for hsp in alignment.hsps:\n        print(hsp)\n    count += 1\n    if(count==5):\n        break\n\nScore 482 (435 bits), expectation 5.5e-117, alignment length 624\nQuery:      59 ACAGAAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGA...GTA 678\n               || ||||||||| |||| | |||| ||  |||| |||| | ||||... ||\nSbjct:     278 ACCGAAAATGGGCAGAGGAGTGAATTATATGGCAATGACACCTGA...TTA 901\nScore 468 (423 bits), expectation 3.4e-113, alignment length 590\nQuery:      63 AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAA...CCC 649\n               |||||||| |||  |||| | || ||||| |||||||| || |||...|||\nSbjct:      11 AAAATGGGTAGACGAATGGATTATTTGGCGATGAAAACCGAGCAA...CCC 600\nScore 443 (400 bits), expectation 3.9e-106, alignment length 597\nQuery:      87 TTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGAT...TAG 679\n               ||||||||||||||||| ||| ||||  |||||||| |||| |||...|||\nSbjct:      25 TTGGCCATGAAAACTGAGCAAATGGCGTTGGCTAATTTGATAGAT...TAG 621\nScore 441 (398 bits), expectation 1.4e-105, alignment length 593\nQuery:      65 AATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAATT...CTG 655\n               ||||||||| |||  | |  | |||||||||||||||||||    ... ||\nSbjct:     254 AATGGGGAG-GAA--GGATAATTTGGCCATGAAAACTGATCC---...ATG 838\nScore 439 (397 bits), expectation 4.8e-105, alignment length 596\nQuery:      63 AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAA...CTG 655\n               |||||||||||    ||| |||  ||||| |||| |||||||| |...|||\nSbjct:     171 AAAATGGGGAGG---ATGGAGTTTTTGGCTATGAGAACTGATCCA...CTG 757\n\n\nThe hsps object has several attributes including the BLAST statistics such as evalue, score, positives, etc. These can be used to extract hits based on certain conditions. E.g., the code below shows saving hits from the previous Blast search with evalue greater than 1e-105 to a new file.\n\nwith open(\"new_file.txt\", \"w\") as file_handle:\n    for alignment in blast_record.alignments:\n        for hsp in alignment.hsps:\n            if (hsp.expect < 1e-105):\n                print(hsp)\n                file_handle.write(str(hsp)+\"\\n\")\n                file_handle.write(\"\\n\")\nprint(\"DONE\")\n\nScore 482 (435 bits), expectation 5.5e-117, alignment length 624\nQuery:      59 ACAGAAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGA...GTA 678\n               || ||||||||| |||| | |||| ||  |||| |||| | ||||... ||\nSbjct:     278 ACCGAAAATGGGCAGAGGAGTGAATTATATGGCAATGACACCTGA...TTA 901\nScore 468 (423 bits), expectation 3.4e-113, alignment length 590\nQuery:      63 AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAA...CCC 649\n               |||||||| |||  |||| | || ||||| |||||||| || |||...|||\nSbjct:      11 AAAATGGGTAGACGAATGGATTATTTGGCGATGAAAACCGAGCAA...CCC 600\nScore 443 (400 bits), expectation 3.9e-106, alignment length 597\nQuery:      87 TTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGAT...TAG 679\n               ||||||||||||||||| ||| ||||  |||||||| |||| |||...|||\nSbjct:      25 TTGGCCATGAAAACTGAGCAAATGGCGTTGGCTAATTTGATAGAT...TAG 621\nDONE"
  },
  {
    "objectID": "BioPython_Intro.html#blast-search-using-sequence-file",
    "href": "BioPython_Intro.html#blast-search-using-sequence-file",
    "title": "14  Introduction to BioPython",
    "section": "14.5 BLAST search using sequence file",
    "text": "14.5 BLAST search using sequence file\nTo run the Blast search using a sequence file instead of gi number, we first need to create a seqeunce object and then pass it on to the qblast function as shown below. To run this code, save the protein sequence below in a new file example1.fasta.\nMFHPGMTSQPSTSNQMYYDPLYGAEQIVQCNPMDYHQANILCGMQYFNNSHNRYPLLPQMPPQFTNDHPY DFPNVPTISTLDEASSFNGFLIPSQPSSYNNNNISCVFTPTPCTSSQASSQPPPTPTVNPTPIPPNAGAV LTTAMDSCQQISHVLQCYQQGGEDSDFVRKAIESLVKKLKDKRIELDALITAVTSNGKQPTGCVTIQRSL DGRLQVAGRKGVPHVVYARIWRWPKVSKNELVKLVQCQTSSDHPDNICINPYHYERVVSNRITSADQSLH VENSPMKSEYLGDAGVIDSCSDWPNTPPDNNFNGGFAPDQPQLVTPIISDIPIDLNQIYVPTPPQLLDNW CSIIYYELDTPIGETFKVSARDHGKVIVDGGMDPHGENEGRLCLGALSNVHRTEASEKARIHIGRGVELT AHADGNISITSNCKIFVRSGYLDYTHGSEYSSKAHRFTPNESSFTVFDIRWAYMQMLRRSRSSNEAVRAQ AAAVAGYAPMSVMPAIMPDSGVDRMRRDFCTIAISFVKAWGDVYQRKTIKETPCWIEVTLHRPLQILDQL LKNSSQFGSS\n\nseq_file = open('example1.fasta')\nresult_handle2 = NCBIWWW.qblast(\"blastp\", \"nr\", seq_file.read())\nseq_file.close()\n\nwith open(\"test_blast.xml\", \"w\") as out_handle:\n    out_handle.write(result_handle2.read())\n\nblast_output = open(\"test_blast.xml\")    \nblast_record = NCBIXML.read(blast_output)\nprint(blast_record.alignments[0])\n\nsp|P45897.1| RecName: Full=Dwarfin sma-4; AltName: Full=MAD protein homolog 3 [Caenorhabditis elegans] >gb|AAA97605.1| SMA-4 [Caenorhabditis elegans]\n           Length = 570\n\n\n\nLet’s say we need only the alignment with the mouse sequence, then, to print first 50 characters of each alignment with the mouse sequence along with corresponding statistics, the following code can be used.\n\nfor alignment in blast_record.alignments:\n    if \"Mus musculus\" in alignment.title:\n        print(alignment.title)\n        for hsp in alignment.hsps:\n            print(hsp.query[0:50])\n            print(hsp.match[0:50])\n            print(hsp.sbjct[0:50])\n            print(hsp.positives, hsp.score, hsp.expect)\n\ngb|KAI2586911.1| SMAD family member 4 [Homo sapiens] >gb|KAI4046350.1| SMAD family member 4 [Homo sapiens] >gb|PNI70022.1| SMAD4 isoform 6 [Pan troglodytes] >gb|PNJ43713.1| SMAD4 isoform 9 [Pongo abelii]\nTAMDSCQQISHVLQCYQQGGEDSDFVRKAIESLVKKLKDKRIELDALITA\nT+ D+C  I H L C++QGGE   F ++AIESLVKKLK+K+ ELD+LITA\nTSNDACLSIVHSLMCHRQGGESETFAKRAIESLVKKLKEKKDELDSLITA\n274 795.0 8.00678e-96\n\n\nTo save the Blast output in csv format, we can use the csv library as shown below.\n\nimport csv\ncsv_out = open(\"blast_out.csv\", \"w\", newline='')\nfor alignment in blast_record.alignments:\n    for hsp in alignment.hsps:\n        new_row = csv.writer(csv_out, delimiter=\",\")\n        new_row.writerow([alignment.title.split(\"|\")[-1], hsp.positives, hsp.expect])\ncsv_out.close()"
  }
]